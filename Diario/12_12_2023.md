# Dia 12 de diciembre

## Comprensión de la razón de altos tiempos de carga
Se ha comprendido la razon de la lentitud de la simulación de HPI
Debido a la mayor precisión del sistema desplegado, la simulación se vuelve más lenta
Con un sistema simple la simulación es mucho más rápida (CPU de tipo atomic vs CPU de tipo timing o minorCPU)
El tipo atomic no espera nada de tiempo a memoria, mientras que timing y minorCPU tienen latencias para reflejar mejor la realidad
Esto deriva en que la simulación completa del sistema tarda más tiempo en lanzarse.

## Comprensión de la arquitectura Cortex A72 y cómo simularla en gem5
Se ha realizado un estudio de la arquitectura para poder realizar una simulación destinada a una Raspberry Pi 4.
Se ha comprendido mejor cómo desplegarla en gem5, los componentes que harían falta para simular este core.
Se ha comprendido también el sistema HPI proporcionado por ARM, donde se especifica de forma abstracta cómo simular un ARMv8-A
Para el caso concreto de Raspberry Pi 4, será necesario adaptar el HPI (que es funcional) para que tenga las características del A72
A diferencia de HPI, se quiere utilizar como base Deriv03CPU (Out Of Order CPU) -> más rendimiento de procesador y más precisión.
La idea es que sobre esta base se construya un CPU con las características del A72, por ejemplo CortexA72CPU.
Sobre este nuevo tipo de CPU se debería de definir, de acuerdo a la documentación ARM y a la especificación HPI:

- __Branch Predictor (BP)__ -> presente en la etapa de fetch y decode, para categorizar las instrucciones a ejecutar
- __Cache L1 separada (instrucciones y datos)__ -> con características propias del A72 definidas en documentación y HPI
- __TLBs para L1_I y L1_D__ -> TLBs para las cachés de datos e instrucciones, ya que están presentes en la documentación.
- __Cache L2__ (unida y con los valores propios de la documentación) 
- __Walker de cachés__ -> utilizado por el controlador de memoria cuando hay fallo de TLB (todo definido en el HPI)
- __Bus de caché L2__

__Nota:__ el controlador de memoria no se tiene que definir ya que supuestamente viene integrado en gem5.

## Comprensión de cómo desplegar una simulación de Raspberry Pi 4
Tras realizar diferentes ejecuciones con el HPI se ha comprendido mejor esta tarea
Definiendo las características del procesador el sistema final puede ser simulado con parámetros anteriormente estudiados
Esto da gran flexibilidad y debería permitir el despliegue tanto de SE como de FSE fácilmente.
Tras observar un script de despliegue de sistema completo para un sistema RPi3 se ha pensado en una forma para realizar esto:

- __Definir la memoria RAM__ -> tipo, canales, tamaño
- __Definir procesador y sus características__ -> tipo, lineas caché, frecuencia, voltaje, config(timing/atomic) + unión CPU-RAM
- __Definir imagen de sistema__ -> creación de dispositivo PCI con la imagen de inicio del sistema
- __Definir workload__ -> es el trabajo a simular. Para meterlo en el sistema se crea otro PCI como si fuera otra imagen
- __Definir disp. I/O__ -> conexión de barras cruzadas y se define el bus de CPU a periféricos y viceversa y se conectan al sistema
- __Crear el sistema__ -> memoria + CPU añadiendo DVFS, RealView, flags SMP, GIC, aarchXX, conexiones I/O y dispositivos PCI

Según el script se requiere de un PMU, algo que es posible que se necesite parchear gem5. En el script se explica el proceso.
Para cada core definido en el sistema:

- __Crear PMU para cada core__ -> con ArmPMU(interrupt=ArmPPI(num=20)). PPI es que interrupción usara el PMU(según realView 20 es OK)
- __Añadir eventos del PMU en el sistema__ -> mirando ArmPMU.py se pueden ver esos eventos. Es simplemente referenciarlos aqui.

__Nota:__ además de los eventos estrictamente necesarios del PMU, se añade otro que es L1_CACHE_MISS, recomendable según el script

Para poder ejecutar el sistema hay que generar los dispositivos del sistema definiendo kernel y bootloader. Para ello:

- __Iniciar kernel__: lectura del kernel en M5_PATH o el especificado en args
- __Definir el bootloader__: en M5_PATH/binaries debe estar el archivo (boot.arm o arm64)
- __Generación de DTB__: con el kernel y el bootloader + el sistema definido se genera un DTB que define el arbol de dispositivos

También es necesario arrancar el terminal que usaremos (antes de tener todo hecho), así como un VNCserver, que es OBLIGATORIO
Con esto el sistema estaría definido y solo decirle al kernel como queremos que realice la simulación.

Para ello se introducen los siguientes parámetros:

- __Consola a utilizar__
- __Timi__ -> "lpj=19988480"
- __Desactivar aleatoriedad del espacio de memoria__ -> para tener una memoria consistente (estática)
- __Ubicación del disco de sistema (vda) y como debe ser montado (rw)__
- __Donde empieza la memoria disponible para el kernel__ -> RealView especifica que el mínimo es 2GB -> "mem=2G@0x80000000"

Finalmente se le dice al sistema que los use con system.workload.command_line = " ".join(kernel_cmd)
